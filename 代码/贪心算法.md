### 贪心算法

通过局部最优，推出整体最优

**手动模拟一下感觉可以局部最优推出整体最优，而且想不到反例， 那么就试一试贪心**

**贪心算法一般分为如下四步：**

* 将问题分解为若干个子问题
* 找出适合的贪心策略
* 求解每一个子问题的最优解
* 将局部最优解堆叠成全局最优解

#### 1、分发饼干

[455. 分发饼干 - 力扣（LeetCode）](https://leetcode.cn/problems/assign-cookies/)

假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。对每个孩子 `i`，都有一个胃口值 `g[i]`，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 `j`，都有一个尺寸 `s[j]` 。如果 `s[j] >= g[i]`，我们可以将这个饼干 `j` 分配给孩子 `i` ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。

**局部最优是大尺寸的饼干喂给胃口大的，充分利用饼干尺寸喂饱一个，全局最优就是喂饱尽可能多的小孩**

```python
class Solution:
    def findContentChildren(self, g, s):
        g.sort()
        s.sort()
        result = 0
        if not s:
            return result
        i, j = len(s) - 1, len(g) - 1
        while i >= 0 and j >= 0:
            if s[i] >= g[j]:
                result += 1
                i -= 1
                j -= 1
             else:
                j -= 1
        return result
```

#### 2、摆动序列

[376. 摆动序列 - 力扣（LeetCode）](https://leetcode.cn/problems/wiggle-subsequence/)

如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 **摆动序列 。**第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。

- 例如， `[1, 7, 4, 9, 2, 5]` 是一个 **摆动序列** ，因为差值 `(6, -3, 5, -7, 3)` 是正负交替出现的。
- 相反，`[1, 4, 7, 2, 5]` 和 `[1, 7, 4, 5, 5]` 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。

**子序列** 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。

给你一个整数数组 `nums` ，返回 `nums` 中作为 **摆动序列** 的 **最长子序列的长度** 。

```python
class Solution:
    def wiggleMaxLength(self, nums):
        diff, cur, result = 0, 0 , 1
        for i in range(len(nums)-1):
            diff = nums[i+1] - nums[i]
            if (diff > 0 and cur <= 0) or (cur >= 0 and diff < 0):
                result += 1
                cur = diff
```

#### 3、最大子数组和

[53. 最大子数组和 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-subarray/)

给你一个整数数组 `nums` ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和

**子数组** 是数组中的一个连续部分。

```python
class Solution:
    def maxSubArray(self, nums):
        result = -float("inf")
        count = 0
        for i in range(len(nums)):
            count += nums[i]
            if count > result:
                result = count
            elif count <= 0:
                count = 0
         return result
```

#### 4、买卖股票的最时机II

[122. 买卖股票的最佳时机 II - 力扣（LeetCode）](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/)

给你一个整数数组 `prices` ，其中 `prices[i]` 表示某支股票第 `i` 天的价格。在每一天，你可以决定是否购买和/或出售股票。你在任何时候 **最多** 只能持有 **一股** 股票。你也可以先购买，然后在 **同一天** 出售。返回 *你能获得的 **最大** 利润* 。

```python
class Solution:
    def maxProfit(self, prices):
        result = 0
        for i in range(len(prices)-1):
            if prices[i+1] > prices[i]:
                result += (prices[i+1] - prices[i])
        return result
```

#### 5、跳跃游戏

给定一个非负整数数组 `nums` ，你最初位于数组的 **第一个下标** 。数组中的每个元素代表你在该位置可以跳跃的最大长度。判断你是否能够到达最后一个下标。

```python
class Solution:
    def canJump(self, nums):
        if len(nums) < 2:
            return True
        i, cover = 0, 0 
        while i <len(nums) and i <= cover:
            cover = max(cover, i + nums[i])
            i += 1
        if cover >= len(nums)-1:
            return True
        retur False
```

#### 6、跳跃游戏II

给你一个非负整数数组 `nums` ，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。你的目标是使用最少的跳跃次数到达数组的最后一个位置。假设你总是可以到达数组的最后一个位置。
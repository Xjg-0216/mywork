#### 目标检测常见问题

[TOC]



##### 1、手写IoU

```python
### IoU
def compute_iou(box1, box2):
    """
    box1 : (x0, y0, x1, y1)
    box2 : (x0, y0, x1, y1)
    """
    x1, y1, x2, y2 = box1
    x3, y3, x4, y4 = box2
    s_box1 = (y2 - y1) * (x2 - x1)
    s_box2 = (y4 - y3) * (x4 - x3)
    left = max(y1, y3)
    top = max(x1, x3)
    right = min(y2, y4)
    bottom = min(x2, x4)
    if left >= right or top >= bottom:
        return 0
    else:
        intersect = (right - left) * (bottom - top)
        area_union = s_box1 + s_box2 - intersect
        return intersect / area_union
    
### GIou
def compute_iou(box1, box2):
    x1, y1, x2, y2 = box1
    x3, y3, x4, y4 = box2
    s_box1 = (y2 - y1)*(x2 - x1)
    s_box2 = (y4 - y2)*(x4 - x2)
    left = max(y1, y3)
    top = max(x1, x3)
    right = min(y2, y4)
    bottom = min(x2, x4)
    if left >= right or top >= bottom:
        return 0
    else:
        intersect = (right - left)*(bottom - top)
        area_union = s_box1 + s_box2 - intersect
        area_c = (max(x2, x4) - min(x1, x3)) *(max(y2, y4) - min(y1, y3))    
        Giou = intersect / area_union + (area_c - area_union) / area_c
        return Giou
    
### DIoU
def compute_iou(box1, box2):
    x1, y1, x2, y2 = box1
    x3, y3, x4, y4 = box2
    s_box1 = (y2 - y1)*(x2 - x1)
    s_box2 = (y4 - y3)*(x4 - x3)
    left = max(x1, x3)
    top = max(y1, y3)
    right = min(x2, x4)
    bottom = min(y2, y4)
    center_x1 = (x2 - x1) / 2
    center_y1 = (y2 - y1) / 2
    center_x2 = (x4 - x3) / 2
    center_y2 = (y4 - y3) / 2
    d_c = ((center_x1 - center_x2)**2 + (center_y1 - center_y2)** 2)
    width = max(x2, x4) - min(x1, x3)
    height = max(y2, y4) - min(y1, y3)
    diag_c = (width**2 + height**2)
    if left >= right or top >= bottom:
        return 0
    else:
        insersect = (bottom - top) * (right - left)
        area_union = s_box1 + s_box2 - insersect
        iou = insersect / area_union
        diou = iou - d_c / diag_c
### CIoU
def compute_iou(box1, box2):
    x1, y1, x2, y2 = box1
    x3, y3, x4, y4 = box2
    left = max(x1, x3)
    top = max(y1, y3)
    right = min(x2, x4)
    bottom = min(y2, y4)
    center_x1, center_y1 = x2 - x1, y2 - y1 
    center_x2, center_y2 = x4 - x3, y4 - y3
    center_dis = (center_x1 - center_x2)**2 +(center_y1 - center_y2)**2
    c_dis = (max(x2, x4) - min(x1, x3))**2 + (max(y2, y4) - min(y1, y3))**2
    arc = (acrtan((x2 - x1) / (y2 - y1))-arctan((x4 - x3) / (y4 - y3)))**2
    v = 4 / pi * arc
    intersect = (right - left)*(bottom - top)
    area_1 = (x2 - x1)*(y2 - y1)
    area_2 = (x4 - x3)*(y4 - y3)
    iou = area_1 + area_2 -intersect
    alpha = v / (1 - iou + v)
    return iou - center_dis / c_dis + alpha * v
```



##### 2、手写NMS

算法实现思路：

先对每个框的score进行排序，首先选择score最高的框

然后与其他框进行比较，当iou大于一定的阈值， 说明两者的重合度高，应该去掉，这样筛选出的框就是和第一框重合度低的框，第一次迭代结束；第二次还是选择score最高的，重复上述过程直到没有框

```python
def nms(dets, thresh):
    #dets: x1, y1, x2, y2, score
    x1 = dets[:, 0]
    y1 = dets[:, 1]
    x2 = dets[:, 2]
    y2 = dets[:, 3]
    score = dets[:, 4]
    areas = (x2 - x1 + 1) * (y2 - y1 + 1)
    order = score.argsort()[::-1]
    keep = []
    while order.size > 0:
        i = order[0]
        keep.append(i)
        xx1 = np.maximum(x1[i], x1[1:])
        yy1 = np.maximum(y1[i], y1[1:])
        xx2 = np.minimum(x2[i], x2[1:])
        yy2 = np.minimum(y2[i], y2;[1:])
        w = np.maximum(0, xx2 - xx1)
        h = np.maximum(0, yy2 - yy1)
        inter = w * h
        iou = inter / (areas[i] + areas[1:] - inter)
        inds = np.where(iou < thresh)[0]
        order = order[inds + 1]
    return keep  
```



##### 3、对比YOLOv1和YOLOv3





##### 4、L1、L2范数

##### 5、SmoothL1 loss相比L1 loss和L2 loss的优势在哪里？这些loss的公式

##### 6、有没有看过anchor free的检测框架

##### 7、小目标如何改进

##### 8、对YOLOv4中的CSP结构有无了解

##### 9、mixup的优势及权值的影响？

##### 10、1*1卷积优势

##### 11、ROI pooling的过程

##### 12、ROI align的改进

##### 13、一阶段和两阶段的区别

##### 14、了解的数据增强策略

##### 15、yolov4和yolov5的具体改进的点

##### 16、anchor-based和anchor-free的区别

##### 17、旋转框检测框和水平框的区别

##### 18、常见的分类损失和回归损失

##### 19、focal loss中的参数，哪个关注难样本，哪个解决长尾问题

##### 20、如果label中有错误标签，我们却不知道，怎么解决

##### 21、anchor怎么设置，不同网络anchor设置的差别（SSD, fasterRCNN, yolov3）

##### 22、BN设置时是每个batch进行计算，但之前的计算资源比较匮乏，batch很小，所以BN计算的时候特别敏感，会震荡不能很好收敛解决方法？

每隔几个batch做BN

